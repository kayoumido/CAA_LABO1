

# This file was *autogenerated* from the file gcm.sage
from sage.all_cmdline import *   # import sage library

_sage_const_16 = Integer(16); _sage_const_0 = Integer(0); _sage_const_8 = Integer(8); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_0xff = Integer(0xff); _sage_const_255 = Integer(255); _sage_const_128 = Integer(128); _sage_const_7 = Integer(7); _sage_const_12 = Integer(12); _sage_const_3 = Integer(3)
from Crypto.Cipher import AES
from Crypto.Util import strxor


def xor(a, b):
    return strxor.strxor(a, b)

# Converts a 128bit string into a polynomial in GF(2^128)
# x has to be the unknown in the polynomial.


def strToPoly(s, x):
    if len(s) != _sage_const_16 :
        raise Exception("Need 128 bit string")
    res = _sage_const_0 
    for i in range(_sage_const_16 ):
        res *= x ** _sage_const_8 
        temp = s[i]
        for j in range(_sage_const_8 ):
            res += x ** j * ((temp >> j) & _sage_const_1 )
    return res

# Converts a polynomial in GF(2^128) into a 128 bitstring


def polyToStr(p):
    coefs = p.polynomial().coefficients(sparse=False)
    coefs.reverse()
    res = _sage_const_0 
    for c in coefs:
        res *= _sage_const_2 
        if c == _sage_const_1 :
            res += _sage_const_1 
    resStr = b""
    for i in range(_sage_const_16 ):
        resStr = (int(res & _sage_const_0xff )).to_bytes(_sage_const_1 , "little") + resStr
        res = res >> _sage_const_8 
    return resStr

# Multiply the 128bit string by the polynomial H.
# Returns a 128bit-string


def multByH(b, H, x):
    p = strToPoly(b, x)
    return polyToStr(p*H)

# Increases by 1 ctr which is a bitstring counter.


def increaseCounter(ctr):
    i = len(ctr) - _sage_const_1 
    while ctr[i] == _sage_const_255 :
        i = i - _sage_const_1 
    res = ctr[:i]+(ctr[i]+int(_sage_const_1 )).to_bytes(_sage_const_1 , "little")+ctr[i+_sage_const_1 :]
    return res


def authenticate(key, ct, T):
    if len(ct) % _sage_const_16  != _sage_const_0 :
        raise Exception(
            "Error: the content to authenticate need to have a length multiple of 128 bits")
    cipher = AES.new(key, AES.MODE_ECB)
    G = PolynomialRing(GF(_sage_const_2 ), names=('y',)); (y,) = G._first_ngens(1)# Ring of polynomials over Z_2
    F = GF(_sage_const_2 **_sage_const_128 , modulus = y**_sage_const_128  + y**_sage_const_7  + y**_sage_const_2  + y + _sage_const_1 , names=('x',)); (x,) = F._first_ngens(1)#GF(2^128) with the GCM modulus
    H = strToPoly(cipher.encrypt(b"\x00"*_sage_const_16 ), x)
    tag = b"\x00"*_sage_const_16 
    for i in range(len(ct)//_sage_const_16 ):
        tag = xor(tag, ct[_sage_const_16 *i: _sage_const_16 *(i+_sage_const_1 )])
        tag = multByH(tag, H, x)
    # Final authentication steps
    # No AD and 64bits for message
    length = b"\x00"*_sage_const_8  + len(ct).to_bytes(_sage_const_8 , "little")
    tag = xor(length, tag)
    tag = multByH(tag, H, x)
    tag = xor(tag, T)
    return tag


def CTR(key, IV, m):
    cipher = AES.new(key, AES.MODE_ECB)
    if len(m) % _sage_const_16  != _sage_const_0 :
        raise Exception(
            "ERROR: the message length has to be a multiple of 128bits")
    if len(IV) != int(_sage_const_12 ):
        raise Exception("requires 96bit IV")
    ctr = (IV + b"\x00"*_sage_const_3 +b"\x02")
    ciphertext = []
    for i in range(len(m)//_sage_const_16 ):
        # Encrypt bloc
        current = m[_sage_const_16 *i: _sage_const_16 *(i+_sage_const_1 )]
        res = xor(current, cipher.encrypt(ctr))
        ciphertext.append(res)
        ctr = increaseCounter(ctr)
    return b"".join(ciphertext)


def GCM_Encrypt(key, IV, m):
    """
    Performs the GCM Encryption function whithout AD
    key is the key of 128 bits.
    IV the IV of 96 bits.
    m the message to encrypt. It has to be a multiple of 128 bits.
    Returns a ciphertext and a tag
    """
    ciphertext = CTR(key, IV, m)
    cipher = AES.new(key, AES.MODE_ECB)
    tag = authenticate(key, ciphertext, cipher.encrypt(
        (IV + b"\x00"*_sage_const_3 +b"\x01")))
    return (ciphertext, tag)


def GCM_Decrypt(key, IV, c):
    ciphertext, given_tag = c
    cipher = AES.new(key, AES.MODE_ECB)
    tag = authenticate(key, ciphertext, cipher.encrypt(
        (IV + b"\x00"*_sage_const_3 +b"\x01")))

    if not given_tag == tag:
        raise Exception("Invalid ciphertext")

    return CTR(key, IV, ciphertext)

    pass


def main():
    # Source for message: https://veganipsum.me/
    message = b"Thai almond milk green pepper Italian linguine puttanesca shaved almonds double dark chocolate blacberies plums salted green tea lime tasty Thai dragon pepper macadamia nut cookies smoky maple tempeh glaze avocado summer chocolate cookie apples peppermint."
    key     = b"Thirty two byte key for AES 256!"
    IV      = b"some very IV"

    encrypted_message = GCM_Encrypt(key, IV, message)

    decrypted_message = GCM_Decrypt(key, IV, encrypted_message)

    print(message == decrypted_message)


if __name__ == '__main__':
    main()

